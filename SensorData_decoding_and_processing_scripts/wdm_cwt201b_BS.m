function [amplitude, wavenumber, direction, directionBS, frequency, wavenmuberSTD,directionSTD,RawOut] = wdm_cwt_BS(elevation,pair,options)
%cwtBS applies the Continuous Wavelet transform Method function released with
%Matlab R2016b  to the elevation timeseries, and returns wave spectra,
% direction and parametric information.
%
% Input:
% ------
% elevation    =  [X*options.n x N] matrix of elevation time series; X=integer,
%                 N is the number of elevation time series from the sensors
%
% pair         =  structure containing the polar/cartesian information
%                 describing the sensor locations, and their relative angles,
%                 distances between eachotehr. Can be generated by
%                 RelativePolarCoords.m
%
% options.nLen =  length of the sampling window (recommended =4096)
%        .lp   = Lowest octave frequency  (for F[Hz], F = 2^lp)
%        .hp   = Highest octave frequency  (for F[Hz], F = 2^hp)
%        .nv   = number of voices
%        .ns   = sampling frequency [Hz]
%
% Output:
% -------
%
%
%--------------------------------------------------------------------------
% Brian Scanlon, 13 December 2017
%--------------------------------------------------------------------------
%elevation=data.wdm.elevation; pair=data.wdm.pair; options=data.wdm.options;
%--Debugging----
% elevation=[data.port.symeo.distance_motCorF' data.bow.symeo.distance_motCorF' data.stbd.symeo.distance_motCorF'];
% options.nLen=4096*4;
% options.lp=-5; %in octaves , equivalent to 2^(lp) Hz (lp=log(0.0625)/log(2);lp=floor(lp))
% options.hp=-1; %in octaves, equivalent to 2^(hp) Hz   (hp=log(1)/log(2);hp=ceil(hp))
% options.ns=27.8; %Symeo sampling freq
% options.nv=4; %number of voices per octave
% options.waveletType='cmor5-3'; %type of wavelet to be used
% pair=data.wdm.pair;%pair; %run RelativePolarCoords.m from Proc_data.m
% %---------------
%elevation=detrend(elevation);

amplitude=[]; wavenumber=[]; direction=[]; directionBS=[]; wavenmuberSTD=[]; directionSTD=[];

%extract the wavelet information
wname=options.waveletType;
precision=10; %(i.e. 2^precision is the number of x-points used to create ..
%the mother wavelet). Then we apply a FFT to the mother wavelet and find
%the centre frequency Fc = (max(abs(FFT(psi))))
[options.fcob,options.Fb,options.Fc]=cmorInfo(wname,precision);



%===============================================
%Prepare the scales and frequency information:
%===============================================
%First we define our desired frequency range:
frequency = 2.^(options.lp:1/options.nv:options.hp+(options.nv-1)/options.nv);
%Using the centre frequency of the Parent morlet wave, we convert the
% frequency into scale, ...(scale = Fc / Freq)
scales=options.Fc./frequency;
%Now we normalise the scale to pseudo frequency (multiply the scale by
%option.Fs). This is necessaary as the wavelet transform is baed upon Pseudo
%Frequencies and scales:
scales=scales.*options.ns;
%We can convert back to Pseudo Frequency by calling
% >> scal2frq(scales,wname)*options.ns
% We need toUsing scal2frq, we can work backwards to replicate scales which
% represent the frequency range 0.5 to 0.0333. The scales required would be
% [5 to 90]*options.ns
%===============================================



%Ensure the elevation array length is a multiple of 4096 chunks (2^12)
elevation=elevation(1:(fix(size(elevation,1)/4096)*4096),:);
numSensors=size(elevation,2);
NumPairs = (numSensors*(size(elevation,2)-1))/2; %number of possible pair combinations: 1.2, 1.3, 2.3


for i=1:options.nLen:length(elevation(:,1))-options.nLen+1
    %----------------------------------------
    %Calculate the CWT for each 4096 segment:
    %----------------------------------------
    fprintf(['\nCalculating segment ' num2str(ceil(i/options.nLen)) ' of ' num2str(...
        length(1:options.nLen:length(elevation(:,1))-options.nLen+1))]);
    AMP = [];
    for jj=1:numSensors
        fprintf(['\n Sensor ' num2str(jj)]);
        eval(['wx',int2str(jj),' = [];'])
        eval(['B',int2str(jj),' = [];'])
        eval(['AMP',int2str(jj),' = [];'])
        x=elevation(i:i+options.nLen-1,jj);
        eval(['[wx',int2str(jj),... %Calculate the discreet wavelet transform
            ']=cwt2016b(x,scales,options.ns,options.Fc);']); %[wt,p,coi] = cwt2016b(x,scales,Fs)
        eval(['PHI',int2str(jj),'=angle(wx',int2str(jj),');'])
        eval(['AMP',int2str(jj),'=abs(wx',int2str(jj),');'])
    end
    %------------------
    
    
    
    %----------------------------------
    %Average the wavelet amplitude data
    %----------------------------------
    AMP = AMP1*0; %copy the first
    for jj = 1:size(elevation,2)
        eval(['RawOut.Pair',int2str(jj),'.Amplitude(i:i+size(AMP,1)-1,1:size(AMP,2)) = AMP',int2str(jj),';'])
        eval(['AMP = AMP + AMP',int2str(jj),';'])
        eval(['clear AMP',int2str(jj),' wx',int2str(jj)])
    end
    AMP = AMP/size(elevation,2); %Normalise the AMPLITUDE data
    clear AMP1 wx1 x
    %------------------------------
    
    
    
    
    %--------------------------------
    %Calculate phases
    %--------------------------------
    [~,MaxFq]=max(frequency(frequency<options.ns/2)); %Determine frequency indices below Nyquist Fq:
    kkm=[];thm=[];kks=[];ths=[]; thmC=[];
    kkmBS=[];thmBS=[];kksBS=[];thsBS=[]; thmCBS=[];
    %select appropriate 4096 segment of the pair info:
    Rk=pair.r_K(i:i+options.nLen-1,:);
    Rj=pair.r_J(i:i+options.nLen-1,:);
    AlphaK=pair.alpha_K(i:i+options.nLen-1,:);
    AlphaJ=pair.alpha_J(i:i+options.nLen-1,:);
    Setconst=1;%test if we set the sensor setup arguments to a constant
if Setconst==1
    Rk=repmat(mean(Rk),size(Rk));
    Rj=repmat(mean(Rj),size(Rj));
    AlphaK=repmat(meanang(AlphaK*pi/180)*180/pi,size(AlphaK));
    AlphaJ=repmat(meanang(AlphaJ*pi/180)*180/pi,size(AlphaJ));
        
end
    %
    for mf=1:MaxFq %For each frequency (below Nyquist Fq)
        %
        %Calc the relative phase of the pairs for the specific frequency (mf):
        l=0;PHI=[];
        for j=1:numSensors-1
            for k=(j+1):numSensors
                l=l+1;
                eval(['PHI(:,l)=PHI',int2str(k),'(:,mf)-PHI',int2str(j),'(:,mf);'])
                
            end
        end
        %shift phases to within the range [-pi,pi]:
        %ill=find(PHI(:) < 0); PHI(ill)=PHI(ill)+2*pi;
        ill=find(PHI(:) > pi); PHI(ill)=PHI(ill)-2*pi;
        ill=find(PHI(:) < -pi); PHI(ill)=PHI(ill)+2*pi;
        %------------
        %Compare the relative phases with other available relative phases:
        l=0;Gamma=[];Theta=[];
        %
        for j=1:NumPairs-1
            for k=(j+1):NumPairs %we ignore that pairs may not be perpendicular here:
                l=l+1;
                %Calculate Gamma coefficient (Donelan et al 1996, pg 1909)
                Gamma(:,l)=( Rk(:,l)./Rj(:,l)) .* ( PHI(:,j)./PHI(:,k) );
                %Donelan et al 1996, Eq (9):
                 Theta(:,l)=atan2(...
                     (Gamma(:,l) .* cos(AlphaK(:,l))-cos(AlphaJ(:,l))),...
                     (sin(AlphaJ(:,l)) - Gamma(:,l) .* sin(AlphaK(:,l)))...
                     );
                      %Donelan et al 1996, Eq (8):
                kk(:,l)=(...
                    (PHI(:,j)./ Rj(:,l)) .* sin(AlphaK(:,l))...
                    -(PHI(:,k)./Rk(:,l)) .* sin(AlphaJ(:,l))...
                    ) ./ (  ...
                    cos(AlphaJ(:,l)) .* sin(AlphaK(:,l))...
                    - cos(AlphaK(:,l)) .* sin(AlphaJ(:,l))...
                    )./...
                    cos(Theta(:,l));
            end
        end
        
        
        ThetaC = Theta +(kk<0)*pi; %If there is negative K, change the direction 180 degrees
        kk = abs(kk);
        %Save the raw output for each pair:
        RawOut.Pair1.Wavenumber(i:i+size(kk,1)-1,mf)=kk(:,1);
        RawOut.Pair2.Wavenumber(i:i+size(kk,1)-1,mf)=kk(:,2);
        RawOut.Pair3.Wavenumber(i:i+size(kk,1)-1,mf)=kk(:,3);
        RawOut.Pair1.Direction(i:i+size(kk,1)-1,mf)=ThetaC(:,1);
        RawOut.Pair2.Direction(i:i+size(kk,1)-1,mf)=ThetaC(:,2);
        RawOut.Pair3.Direction(i:i+size(kk,1)-1,mf)=ThetaC(:,3);
        RawOut.Pair1.DirectionUnCorr(i:i+size(kk,1)-1,mf)=Theta(:,1);
        RawOut.Pair2.DirectionUnCorr(i:i+size(kk,1)-1,mf)=Theta(:,2);
        RawOut.Pair3.DirectionUnCorr(i:i+size(kk,1)-1,mf)=Theta(:,3);
        %----------------------------------
        thm = [thm meanang(Theta')'];
        thmC = [thmC meanang(ThetaC')']; %one where the -k directions are reversed
        ths = [ths std(Theta')'];
%         
%         figure;
%         subplot(2,3,1), plot(Theta(:,1)); title('Theta(:,1)'); subplot(2,3,2), plot(Theta(:,2));title('gamma 2'); subplot(2,3,3), plot(Theta(:,3));title('gamma 3');
%         subplot(2,3,4), plot(thm.*180/pi); title('Theta');subplot(2,3,5), plot(kk); title('wavenumber');subplot(2,3,6), plot(thmC.*180/pi); title('ThetaCorr');
%         currentFigure = gcf; title(currentFigure.Children(end), ['freq # ' num2str(mf)]);
        
        
        kkm = [kkm mean(kk')'];
        kks = [kks std(kk')'];   %wavenumber standard deviation
        
    end
    
    
    
    
    clear Theta Gamma kk j k l
    
    if i == 1
        amplitude=AMP;
        direction=round(thmC*180/pi);
        directionUnCorr=round(thm*180/pi);
        wavenumber=kkm;
        wavenmuberSTD=kks;
        directionSTD=round(ths*180/pi);
    else
        amplitude=[amplitude;AMP];
        wavenumber=[wavenumber;kkm];
        direction=[direction;round(thmC*180/pi)];
        directionUnCorr=[directionUnCorr;round(thm*180/pi)];
        wavenmuberSTD=[wavenumber;kks];
        directionSTD=[directionSTD;round(ths*180/pi)];
    end
    clear AAp ddd kkmp f
end

end








%--------------------------------------------------------------------------
%----------------------------cwtBS-----------------------------------------
function [wt,p,coi] = cwt2016b(x,scales,Fs,Fc)
% x = Elevation of the input signal
% scales = the scales of child waveletes to be created from mother wavelet
% WAV = specify the mother wavelet

% Debug
%-------
%x=x; scales=scales; Fs=27.8;


% Detrend signal
x = detrend(x,0);
x = x(:)';



%Define the parameters
Norig = numel(x);  
dt = 1/Fs;
NbSc = length(scales);


%pad the start and end of signal::
padvalue = floor(Norig/2);
x =[fliplr(x(1:padvalue)) x x(end:-1:end-padvalue+1)];
% Length of data plus any extension
n = length(x);

% Frequency vector sampling the Fourier transform of the wavelet
f = (1:fix(n/2));
f = f/n;
f = [0, f, -f(fix((n-1)/2):-1:1)];



% Loop through all scales and compute transform
%---------
xfft = fft(x); % Compute FFT of the (padded) time series:
%wavelet Fourier transform WFT (psift) in the frequency plane:
[psift,freq]  = waveftBS(f,scales,Fc);
%calculate the inverse fourier transform of the signal*cwt:
cwtcfs = ifft(repmat(xfft,NbSc,1).*psift,[],2);
cfs = cwtcfs(:,padvalue+1:padvalue+Norig); %Remove the padded data:


FourierFactor = 1/Fc;
sigmaT = 1/sqrt(2);
coiScalar = FourierFactor/sigmaT;
freq = (freq.*Fs)'; %change the psuedo freuency to real frequency
%Compute the Cone of Influence:
coitmp = coiScalar*dt*[1E-5,1:((Norig+1)/2-1),fliplr((1:(Norig/2-1))),1E-5];
coitmp = coitmp(:);

%Nargout:
wt = cfs'.*sigmaT; %adding the Sigma T here to normalise the Amplitude!
p = freq';
coi = 1./coitmp;
end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------






%-----------------------------------------------------------------------
%-----------------------------------------------------------------------
function [wft,frequencies] = waveftBS(f,scales,Fc)
%WAVEFT Wavelet Fourier transform.
%   WAVEFT computes the wavelet values in the frequency plane.


NbFrq  = length(f);
NbSc = length(scales);
wft = zeros(NbSc,NbFrq);
omega_0=Fc;     %Here we remove the 
mul = 2;

for jj = 1:NbSc
    expnt = -(scales(jj).*f - omega_0).^2/2.*(f > 0);
    wft(jj,:) = mul*exp(expnt).*(f > 0);
end
FourierFactor = omega_0/(2*pi);
frequencies = FourierFactor./scales;
end
%-----------------------------------------------------------------------
%-----------------------------------------------------------------------
