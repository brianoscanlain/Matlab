function [amplitude, wavenumber, direction, directionUnCorr, frequency] = wdmBS(elevation,pair,options)
%wdmBS applies the Wavelet Directional Method (Donelan et al., 1996) to the
% elevation timeseries, and returns wave spectra, direction and parametric
% information.
%
% Input:
% ------
% elevation    =  [X*options.n x N] matrix of elevation time series; X=integer,
%                 N is the number of elevation time series from the sensors
%
% pair         =  structure containing the polar/cartesian information
%                 describing the sensor locations, and their relative angles,
%                 distances between eachotehr. Can be generated by
%                 RelativePolarCoords.m
%
% options.nLen =  length of the sampling window (recommended =4096)
%        .lp   = Lowest octave frequency  (for F[Hz], F = 2^lp)
%        .hp   = Highest octave frequency  (for F[Hz], F = 2^hp)
%        .nv   = number of voices
%        .ns   = sampling frequency [Hz]
%
% Output:
% -------
%
%
%--------------------------------------------------------------------------
% Brian Scanlon, 13 December 2017
%--------------------------------------------------------------------------

%--Debugging----
% elevation=[data.port.symeo.distance_motCorF' data.bow.symeo.distance_motCorF'...
%     data.stbd.symeo.distance_motCorF'];
% options.nLen=4096;
% options.lp=-5; %in octaves , equivalent to 2^(lp) Hz (lp=log(0.0625)/log(2);lp=floor(lp))
% options.hp=-1; %in octaves, equivalent to 2^(hp) Hz   (hp=log(1)/log(2);hp=ceil(hp))
% options.ns=27.8; %Symeo sampling freq
% options.nv=4; %number of voices per octave
% pair=data.wdm.pair;%pair; %run RelativePolarCoords.m from Proc_data.m
% %---------------
%elevation=detrend(elevation);

%Cauculate the frequency (please note, the wavelet subfunction returns this
%aswell (variable called 'f').
frequency = 2.^(options.lp:1/options.nv:options.hp+(options.nv-1)/options.nv);


%Ensure the elevation array length is a multiple of 4096 chunks (2^12)
elevation=elevation(1:(fix(size(elevation,1)/4096)*4096),:);
numSensors=size(elevation,2);
NumPairs = (numSensors*(size(elevation,2)-1))/2; %number of possible pair combinations: 1.2, 1.3, 2.3


for i=1:options.nLen:length(elevation(:,1))-options.nLen+1
    %----------------------------------------
    %Calculate the CWT for each 4096 segment:
    %----------------------------------------
    AMP = [];
    for jj=1:numSensors
        eval(['wx',int2str(jj),' = [];'])
        eval(['B',int2str(jj),' = [];'])
        eval(['AMP',int2str(jj),' = [];'])
        x=elevation(i:i+options.nLen-1,jj);
        eval(['[wx',int2str(jj),... %Calculate the discreet wavelet transform
            ',f]=wavelet(x,options.lp,options.hp,options.nv,options.ns);']);
        eval(['PHI',int2str(jj),'=angle(wx',int2str(jj),');'])
        eval(['AMP',int2str(jj),'=abs(wx',int2str(jj),');'])
    end
    %------------------
    
    
    
    
    %----------------------------------
    %Average the wavelet amplitude data 
    %----------------------------------
    AMP = AMP1; %copy the first
    for jj = 2:size(elevation,2)
        eval(['AMP = AMP + AMP',int2str(jj),';'])
        eval(['clear AMP',int2str(jj),' wx',int2str(jj)])
    end
    AMP = AMP/size(elevation,2); %Normalise the AMPLITUDE data
    clear AMP1 wx1 x
    %------------------------------
    
    
    
    
    %--------------------------------
    %Calculate phases
    %--------------------------------
    [~,MaxFq]=max(f(f<options.ns/2)); %Determine frequency indices below Nyquist Fq:
    kkm=[];thm=[];kks=[];ths=[]; thmC=[];
    %select appropriate 4096 segment of the pair info:
    Rk=pair.r_K(i:i+options.nLen-1,:);
    Rj=pair.r_J(i:i+options.nLen-1,:);
    AlphaK=pair.alpha_K(i:i+options.nLen-1,:);
    AlphaJ=pair.alpha_J(i:i+options.nLen-1,:);
    %
    for mf=1:MaxFq %For each frequency (below Nyquist Fq)
        %
        %Calc the relative phase of the pairs for the specific frequency (mf):
        l=0;PHI=[];
        for j=1:numSensors-1
            for k=(j+1):numSensors
                l=l+1;
                eval(['PHI(:,l)=PHI',int2str(k),'(:,mf)-PHI',int2str(j),'(:,mf);'])
                
            end
        end
        %shift phases to within the range [-pi,pi]:
         %ill=find(PHI(:) < 0); PHI(ill)=PHI(ill)+2*pi;
        ill=find(PHI(:) > pi); PHI(ill)=PHI(ill)-2*pi;
        ill=find(PHI(:) < -pi); PHI(ill)=PHI(ill)+2*pi;
        %------------
        %Compare the relative phases with other available relative phases:
        l=0;Gamma=[];Theta=[];
        %
        for j=1:NumPairs-1 
            for k=(j+1):NumPairs %we ignore that pairs may not be perpendicular here:
                l=l+1;
                %Calculate Gamma coefficient (Donelan et al 1996, pg 1909)
                Gamma(:,l)=( Rk(:,l)./Rj(:,l)) .* ( PHI(:,j)./PHI(:,k) );
                %Donelan et al 1996, Eq (9):
                Theta(:,l)=atan2(...
                    (Gamma(:,l) .* cos(AlphaK(:,l))-cos(AlphaJ(:,l))),...
                    (sin(AlphaJ(:,l)) - Gamma(:,l) .* sin(AlphaK(:,l)))...
                    );
                %Donelan et al 1996, Eq (8):
                kk(:,l)=(...
                    (PHI(:,j)./ Rj(:,l)) .* sin(AlphaK(:,l))...
                    -(PHI(:,k)./Rk(:,l)) .* sin(AlphaJ(:,l))...
                    ) ./ (  ...
                    cos(AlphaJ(:,l)) .* sin(AlphaK(:,l))...
                    - cos(AlphaK(:,l)) .* sin(AlphaJ(:,l))...
                    )./...
                    cos(Theta(:,l));
            end
        end

        
        ThetaC = Theta+(kk<0)*pi; %If there is negative K, change the direction 180 degrees 
        kk = abs(kk);
        thm = [thm meanang(Theta')'];
        thmC = [thmC meanang(ThetaC')']; %one where the -k directions are reversed
        ths = [ths std(Theta')'];
        kkm = [kkm mean(kk')'];
        kks = [kks std(kk')'];   %wavenumber standard deviation
    end       
    
    
    
    
    clear Theta Gamma kk j k l
    
    if i == 1
        amplitude=AMP;
        direction=round(thm*180/pi);
        directionUnCorr=round(thmC*180/pi);
        wavenumber=kkm;
    else
        amplitude=[amplitude;AMP];
        wavenumber=[wavenumber;kkm];
        direction=[direction;round(thm*180/pi)];
        directionUnCorr=[directionUnCorr;round(thmC*180/pi)];
    end
    clear AAp ddd kkmp f
end

end








%---------------------------Wavelet Function-------------------------------
%--------------------------------------------------------------------------
function [W,a]=wavelet(x,omin,omax,nv,ns)
%function [W,a]=wavelet(x,omin,omax,nv,ns)
%
%  Octave min is related to the lowest frequency such as 2^omin
%  For example Octave min = -2 --> .25 Hz
%  Octave max for the Highest frequency 2^omax
%  nv == number of voices
%  ns == sampling frequency [Hz]
%
% Bertrand Chapron's Wavelet Transform code.

%    Syntax W complex coeff. = wavelet ( x signal a column vector)
%
%Even though the concept is pretty wide for scale analysis these
%frequencies will be related to the peak in the Fourier domain
%
%x=x; omin=options.lp; omax=options.hp; nv=options.nv; ns=options.ns;

n=length(x);
f=fft(x);f=f(1:n/2+1);f(1)=f(1)/2; %FFT of x

ntot=(abs(omax-omin)+1)*nv;
for i=1:ntot
    F(:,i)=f; %expand matrix of frequencies
end

k=1;
for i=omin:omax  %for each octave
    for j=0:nv-1   % various voices (for each octave)
        a(k)=2^(i+j/nv); %create scale
        w(:,k)=momo(1/a(k),n,ns);
        k=k+1;
    end
end
W=ifft(2*F.*w,n);
end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------






%---------------------------MOMO Function----------------------------------
%--------------------------------------------------------------------------
function f=momo(a,n,ns)
%  To generate Child Morlet Wavelet in Fourier Domain
% nu is a timescale (1/freq * [0:F_nyq]), where a=1/freq
nu=a*ns*(0:n/2)'/n; %Normalised up to Nyquist frequency
f=exp(-1/sqrt(2)*((nu-1)/.220636).^2);   %The 0.220636 is a dilation factor
end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------



%---------------------------meanang Function----------------------------------
%--------------------------------------------------------------------------
function ma=meanang(A)
%ma = meanang(A) [radians]
%Returns the columnwise angular mean of an array of angles (in radians)
ma = atan2(mean(sin(A)),mean(cos(A)));
end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------

