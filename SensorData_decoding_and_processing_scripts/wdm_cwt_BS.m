function [amplitude, wavenumber, direction, directionUnCorr, frequency] = wdm_cwt_BS(elevation,pair,options)
%cwtBS applies the Continuous Wavelet transform Method function released with
%Matlab R2016b  to the elevation timeseries, and returns wave spectra,
% direction and parametric information.
%
% Input:
% ------
% elevation    =  [X*options.n x N] matrix of elevation time series; X=integer,
%                 N is the number of elevation time series from the sensors
%
% pair         =  structure containing the polar/cartesian information
%                 describing the sensor locations, and their relative angles,
%                 distances between eachotehr. Can be generated by
%                 RelativePolarCoords.m
%
% options.nLen =  length of the sampling window (recommended =4096)
%        .lp   = Lowest octave frequency  (for F[Hz], F = 2^lp)
%        .hp   = Highest octave frequency  (for F[Hz], F = 2^hp)
%        .nv   = number of voices
%        .ns   = sampling frequency [Hz]
%
% Output:
% -------
%
%
%--------------------------------------------------------------------------
% Brian Scanlon, 13 December 2017
%--------------------------------------------------------------------------

%--Debugging----
% elevation=[data.port.symeo.distance_motCorF' data.bow.symeo.distance_motCorF' data.stbd.symeo.distance_motCorF'];
% options.nLen=4096;
% options.lp=-5; %in octaves , equivalent to 2^(lp) Hz (lp=log(0.0625)/log(2);lp=floor(lp))
% options.hp=-1; %in octaves, equivalent to 2^(hp) Hz   (hp=log(1)/log(2);hp=ceil(hp))
% options.ns=27.8; %Symeo sampling freq
% options.nv=4; %number of voices per octave
% options.waveletType='cmor5-3'; %type of wavelet to be used
% pair=data.wdm.pair;%pair; %run RelativePolarCoords.m from Proc_data.m
% %---------------
%elevation=detrend(elevation);



%extract the wavelet information
wname=options.waveletType;
precision=10; %(i.e. 2^precision is the number of x-points used to create ..
%the mother wavelet). Then we apply a FFT to the mother wavelet and find
%the centre frequency Fc = (max(abs(FFT(psi))))
[options.fcob,options.Fb,options.Fc]=cmorInfo(wname,precision);



%===============================================
%Prepare the scales and frequency information:
%===============================================
%First we define our desired frequency range:
frequency = 2.^(options.lp:1/options.nv:options.hp+(options.nv-1)/options.nv);
%Using the centre frequency of the Parent morlet wave, we convert the
% frequency into scale, ...(scale = Fc / Freq)
scales=options.Fc./frequency;
%Now we normalise the scale to pseudo frequency (multiply the scale by
%option.Fs). This is necessaary as the wavelet transform is baed upon Pseudo
%Frequencies and scales:
scales=scales.*options.ns;
%We can convert back to Pseudo Frequency by calling
% >> scal2frq(scales,wname)*options.ns
% We need toUsing scal2frq, we can work backwards to replicate scales which
% represent the frequency range 0.5 to 0.0333. The scales required would be
% [5 to 90]*options.ns
%===============================================



%Ensure the elevation array length is a multiple of 4096 chunks (2^12)
elevation=elevation(1:(fix(size(elevation,1)/4096)*4096),:);
numSensors=size(elevation,2);
NumPairs = (numSensors*(size(elevation,2)-1))/2; %number of possible pair combinations: 1.2, 1.3, 2.3


AMP = [];
for jj=1:numSensors
    fprintf(['\n Sensor ' num2str(jj)]);
    eval(['wx',int2str(jj),' = [];'])
    eval(['B',int2str(jj),' = [];'])
    eval(['AMP',int2str(jj),' = [];'])
    x=elevation(:,jj);
    eval(['[wx',int2str(jj),... %Calculate the discreet wavelet transform
        ']=CWTBS(x,scales,wname);']);
    eval(['PHI',int2str(jj),'=angle(wx',int2str(jj),');'])
    eval(['AMP',int2str(jj),'=abs(wx',int2str(jj),');'])
end
%------------------



%----------------------------------
%Average the wavelet amplitude data
%----------------------------------
AMP = AMP1; %copy the first
for jj = 2:size(elevation,2)
    eval(['AMP = AMP + AMP',int2str(jj),';'])
    eval(['clear AMP',int2str(jj),' wx',int2str(jj)])
end
AMP = AMP/size(elevation,2); %Normalise the AMPLITUDE data
clear AMP1 wx1 x
%------------------------------




%--------------------------------
%Calculate phases
%--------------------------------
[~,MaxFq]=max(frequency(frequency<options.ns/2)); %Determine frequency indices below Nyquist Fq:
kkm=[];thm=[];kks=[];ths=[]; thmC=[];
%select appropriate 4096 segment of the pair info:
Rk=pair.r_K(1:size(AMP,1),:);
Rj=pair.r_J(1:size(AMP,1),:);
AlphaK=pair.alpha_K(1:size(AMP,1),:);
AlphaJ=pair.alpha_J(1:size(AMP,1),:);
%
for mf=1:MaxFq %For each frequency (below Nyquist Fq)
    %
    %Calc the relative phase of the pairs for the specific frequency (mf):
    l=0;PHI=[];
    for j=1:numSensors-1
        for k=(j+1):numSensors
            l=l+1;
            eval(['PHI(:,l)=PHI',int2str(k),'(:,mf)-PHI',int2str(j),'(:,mf);'])
            
        end
    end
    %shift phases to within the range [-pi,pi]:
    %ill=find(PHI(:) < 0); PHI(ill)=PHI(ill)+2*pi;
    ill=find(PHI(:) > pi); PHI(ill)=PHI(ill)-2*pi;
    ill=find(PHI(:) < -pi); PHI(ill)=PHI(ill)+2*pi;
    %------------
    %Compare the relative phases with other available relative phases:
    l=0;Gamma=[];Theta=[];
    %
    for j=1:NumPairs-1
        for k=(j+1):NumPairs %we ignore that pairs may not be perpendicular here:
            l=l+1;
            %Calculate Gamma coefficient (Donelan et al 1996, pg 1909)
            Gamma(:,l)=( Rk(:,l)./Rj(:,l)) .* ( PHI(:,j)./PHI(:,k) );
            %Donelan et al 1996, Eq (9):
            Theta(:,l)=atan2(...
                (Gamma(:,l) .* cos(AlphaK(:,l))-cos(AlphaJ(:,l))),...
                (sin(AlphaJ(:,l)) - Gamma(:,l) .* sin(AlphaK(:,l)))...
                );
            %Donelan et al 1996, Eq (8):
            kk(:,l)=(...
                (PHI(:,j)./ Rj(:,l)) .* sin(AlphaK(:,l))...
                -(PHI(:,k)./Rk(:,l)) .* sin(AlphaJ(:,l))...
                ) ./ (  ...
                cos(AlphaJ(:,l)) .* sin(AlphaK(:,l))...
                - cos(AlphaK(:,l)) .* sin(AlphaJ(:,l))...
                )./...
                cos(Theta(:,l));
        end
    end
    
    
    ThetaC = Theta+(kk<0)*pi; %If there is negative K, change the direction 180 degrees
    kk = abs(kk);
    thm = [thm meanang(Theta')'];
    thmC = [thmC meanang(ThetaC')']; %one where the -k directions are reversed
    ths = [ths std(Theta')'];
    kkm = [kkm mean(kk')'];
    kks = [kks std(kk')'];   %wavenumber standard deviation
end




clear Theta Gamma kk j k l


    amplitude=AMP;
    direction=round(thm*180/pi);
    directionUnCorr=round(thmC*180/pi);
    wavenumber=kkm;
clear AAp ddd kkmp f
end









%--------------------------------------------------------------------------
%----------------------------cwtBS-----------------------------------------
function [coefs] = CWTBS(Elevation,scales,WAV)
%Elevation= Elevation of the input signal
%scales = the scales of child waveletes to be created from mother wavelet
%WAV = specify the mother wavelet

% Debug
%-------
%Elevation=x; scales=scales; WAV=wname;

%Housework:
%----------
ySIG    = Elevation;
lenSIG  = length(ySIG);
xSIG    = (1:lenSIG);
stepSIG = 1;

% Check wavelet.
%---------------
precision = 10; % precis = 15;
[psi,x] = intwaveBS(WAV,precision);
stepWAV = x(2)-x(1);

psi = conj(psi); %Take ther conjugate of the mother wavelet


%More Housework:
%---------------
x = x-x(1);   %shifts the xlimits of mother wavelet from [-8 8] to [0 16]
xMaxWAV = x(end);
ySIG   = ySIG(:)';
nb_SCALES = length(scales); %number of scales used
coefs     = zeros(nb_SCALES,lenSIG); %allocate memory for coefficients
ind  = 1; %counter


%Calculate the coefficients for the various scales:
%--------------------------------------------------
for k = 1:nb_SCALES
    a = scales(k);    %select the scale
    a_SIG = a/stepSIG;
    j = 1+floor((0:a_SIG*xMaxWAV)/(a_SIG*stepWAV)); %method used for scaling the
    %mother wavelet by selecting certain indexes (j).
    if length(j)==1
        j = [1 1];
    end
    f  = fliplr(psi(j)); %here f represents sample wavelet which is
    %dilated mother wavelet
    coefs(ind,:) = -sqrt(a)*wkeep1(diff(wconv1(ySIG,f)),lenSIG); %finds the
    %convolution of signal SIG and f
    %WKEEP1  Keep part of a vector.
    %WCONV1(X,F) performs the 1-D convolution of the vectors X and F.
    ind = ind+1;
end
coefs=coefs'; %get the transpose of the matrix (swap the rows and columns)
end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------







%--------------------------------------------------------------------------
%----------------------------intwaveBS-------------------------------------
function [Sum_psi,x] = intwaveBS(wname,precision)
%precision=precision; %keep this between 1 and 20. matlab default=8
%Make sure it is cmor (complex morlet wavelet without scale function):
if strcmp(wname(1:4),'cmor')
    [psi,x] = wavefunBS(wname,precision);
end

step = x(2)-x(1);
Sum_psi = cumsum(psi)*step;    %function integrated value from n=0...ith value
%Plot:
% plot(x,psi)
% hold on
% plot(x,Sum_psi)
end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------





%--------------------------------------------------------------------------
%---------------------------wavefunBS--------------------------------------
function [psi,x] = wavefunBS(wname,precision)
%[~,~,~,bounds] =  ...
% wavemngr('fields',wname,'type','file','fn','bounds');
bounds=[-8 8];
iter=precision;  %=10     %2^precision are the number of points in mother wavelet
np = 2^iter;     %=1024 for iter=10
lb = bounds(1); %=-8
ub = bounds(2); %=+8
[psi,x] = cmorwavfBS(lb,ub,np,wname);  %fname = cmorwavf
%wname = cmor5-3
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
end






%--------------------------------------------------------------------------
%-------------------------cmorwavfBS---------------------------------------
function [psi,x] = cmorwavfBS(lb,ub,np,Fb,Fc)
%LB = lower bound
%UB = upper bound
%N = Number of points (a.k.a 2^precision)
%Fb = function coefficient b, normalized frequency \omega_0
%Fc = function coefficient c,
%                       ###(cmorFb-Fc)###
%
%PSI(X) = ((pi*FB)^(-0.5))*exp(2*i*pi*FC*X)*exp(-(X^2)/FB)
nbIn = nargin;
switch nbIn
    case {0,1,2}
        error(message('Wavelet:FunctionInput:NotEnough_ArgNum'));
    case 3
        Fc = 1; Fb = 1;
    case 4
        if ischar(Fb)
            label = deblank(Fb);
            ind   = strncmpi('cmor',label,4);
            if isequal(ind,1)
                label(1:4) = [];
                len = length(label);
                if len>0
                    ind = strfind(label,'-');
                    if isempty(ind)
                        Fb = []; % error
                    else
                        Fb = wstr2num(label(1:ind-1));
                        label(1:ind) = [];
                        Fc = wstr2num(label);
                    end
                end
            else
                Fc = []; % error
            end
        else
            Fb = []; Fc = []; % error
        end
        
    case 5
end       %at this stage we should be ready to calculate the mother wavelet
x = linspace(lb,ub,np);  % wavelet support.
psi = ((pi*Fb)^(-0.5))*exp(2*1i*pi*Fc*x).*exp(-(x.*x)/Fb);
end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
